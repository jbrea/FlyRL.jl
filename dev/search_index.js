var documenterSearchIndex = {"docs":
[{"location":"simulations/","page":"Simulations","title":"Simulations","text":"Modules = [FlyRL]\nPages = [\"simulators.jl\"]","category":"page"},{"location":"simulations/#FlyRL.Environment","page":"Simulations","title":"FlyRL.Environment","text":"Environment(; preprocessor,\n              pattern = \"GBB\",\n              shock = shock_function(pattern),\n              state = rand_state(preprocessor, pattern, shock))\n\nDefine an environment that can be used for simulations.\n\n\n\n\n\n","category":"type"},{"location":"simulations/#FlyRL.random_track-Tuple{}","page":"Simulations","title":"FlyRL.random_track","text":"random_track(; N, pattern, shock)\n\n\n\n\n\n\n","category":"method"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Encoders can be used to transform the raw data in different ways. This can be done in two ways, illustrated here with the ShockArmEncoder:","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Create a new data frame with the transformed data","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"using DataFrames\nimport FlyRL: encode, ShockArmEncoder, random_track\ntrack = random_track(N = 100)\nencode(ShockArmEncoder(), track) |> DataFrame","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Append the transformed data directly to the original data frame","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"using DataFrames\nimport FlyRL: encode!, ShockArmEncoder, random_track\ntrack = random_track(N = 100)\nencode!(ShockArmEncoder(), track)","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Here is a list of built-in encoders.","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Modules = [FlyRL]\nPages = [\"encoders.jl\"]","category":"page"},{"location":"encoders/#FlyRL.AngleEncoder","page":"Encoders","title":"FlyRL.AngleEncoder","text":"AngleEncoder()\n\nEncodes angles between subsequent orientations.\n\nConvention: the same row should contain the delta values that lead to the current value, i.e. delta values should start with missing.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.AngleEncoder2D","page":"Encoders","title":"FlyRL.AngleEncoder2D","text":"AngleEncoder2D()\n\nEncodes angles as (sin(angle), cos(angle)) (see also AngleEncoder).\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.ArmEncoder-Tuple{}","page":"Encoders","title":"FlyRL.ArmEncoder","text":"ArmEncoder(; with_outliers)\n\n\nEncodes arms of the maze as \"left\", \"middle\", \"right\", \"center\". Points outside the maze are marked as \"outlier\" if with_outliers = true.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.ClosestWallEncoder","page":"Encoders","title":"FlyRL.ClosestWallEncoder","text":"ClosestWallEncoder(encoder)\n\nEncodes the closest wall as determined with encoder (either FourWallsEncoder, SixWallsEncoder or EightWallsEncoder).\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.ColorEncoder-Tuple{}","page":"Encoders","title":"FlyRL.ColorEncoder","text":"ColorEncoder(; colordict, with_outliers)\n\n\nEncode color based on track.pattern.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.ColumnPicker","page":"Encoders","title":"FlyRL.ColumnPicker","text":"ColumnPicker(colname::Symbol)\n\nPicks a column from a data frame.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DeltaPositionEncoder","page":"Encoders","title":"FlyRL.DeltaPositionEncoder","text":"DeltaPositionEncoder()\n\nEncodes Δx and Δy from x and y.\n\nConvention: the same row should contain the delta values that lead to the current value, i.e. delta values should start with missing.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DeltaPositionIndexEncoder","page":"Encoders","title":"FlyRL.DeltaPositionIndexEncoder","text":"DeltaPositionIndexEncoder(; maxradius = 20, stepsize = 1)\n\nEncodes relative positions (Δx, Δy) with an integer, based on a 2D grid with stepsize and largest relative position Δx^2 + Δy^2 = maxradius^2.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DeltaTimeEncoder","page":"Encoders","title":"FlyRL.DeltaTimeEncoder","text":"DeltaTimeEncoder()\n\nEncodes Δt from t; uses default 0.15, if t is missing.\n\nConvention: the same row should contain the delta values that lead to the current value, i.e. delta values should start with missing.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DurationPerStateEncoder","page":"Encoders","title":"FlyRL.DurationPerStateEncoder","text":"DurationPerStateEncoder(encoder)\n\nEncode the duration that is spent in a given state.\n\nExample\n\nencode(DurationPerStateEncoder(ShockArmEncoder()), random_track()) |> DataFrame\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DynamicCompressEncoder-Union{Tuple{N}, Tuple{Union{Symbol, Tuple{Vararg{Symbol, N}}}, Vararg{Any}}} where N","page":"Encoders","title":"FlyRL.DynamicCompressEncoder","text":"DynamicCompressEncoder(compress_on, encoders...)\n\nMerge subsequent states of compress_on into one state.\n\nExample\n\nencode(DynamicCompressEncoder(ShockArmEncoder()), random_track()) |> DataFrame\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.FutureDeltaTimeEncoder","page":"Encoders","title":"FlyRL.FutureDeltaTimeEncoder","text":"FutureDeltaTimeEncoder()\n\nSame as DeltaTimeEncoder but offset by one, i.e. the same row contains the delta value that leads to the next value.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.InShockArmEncoder","page":"Encoders","title":"FlyRL.InShockArmEncoder","text":"InShockArmEncoder()\n\nEncodes if the position is in the shock arm.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.LevelEncoder","page":"Encoders","title":"FlyRL.LevelEncoder","text":"LevelEncoder(encoder)\n\nEncode level as an integer for a categorical encoder (like ShockArmEncoder).\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.MarkovKEncoder-Tuple{Any, Vararg{Any}}","page":"Encoders","title":"FlyRL.MarkovKEncoder","text":"MarkovKEncoder(K, encoders)\n\n\nCreate copies of the original encoders with offsets up to K. Appends ˌk to copy with offset k.\n\nExample\n\nencode(MarkovKEncoder(3, DynamicCompressEncoder(:arm, ArmEncoder())), random_track()) |> DataFrame\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.OrientationEncoder","page":"Encoders","title":"FlyRL.OrientationEncoder","text":"OrientationEncoder()\n\nEncodes orientations based on Δx and Δy.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.SemanticEncoder3-Tuple{}","page":"Encoders","title":"FlyRL.SemanticEncoder3","text":"SemanticEncoder3(; with_outliers)\n\n\nEncodes positions of the maze as \"center\", \"arm\" or \"turn\". Points outside the maze are marked as \"outlier\" if with_outliers = true.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.SemanticEncoder7-Tuple{}","page":"Encoders","title":"FlyRL.SemanticEncoder7","text":"SemanticEncoder7(; with_outliers)\n\n\nEncodes positions of the maze as \"center\", \"left arm\", \"left turn\", \"middle arm\", \"middle turn\", \"right arm\", \"right turn\". Points outside the maze are marked as \"outlier\" if with_outliers = true.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.ShockArmEncoder-Tuple{}","page":"Encoders","title":"FlyRL.ShockArmEncoder","text":"ShockArmEncoder(; with_outliers)\n\n\nEncodes arms of the maze as \"neutral A\", \"neutral B\", \"shock\" and \"center\". Points outside the maze are marked as \"outlier\" if with_outliers = true.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.SpeedEncoder-Tuple{}","page":"Encoders","title":"FlyRL.SpeedEncoder","text":"SpeedEncoder(; outlier_threshold, return_outliers)\n\n\nEncode the speed based on vx and vy (see VelocityEncoder). Speed values above outlier_threshold are returned as missing. If return_outliers = true, return also a vector of outlier values.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.VectorEncoder-Tuple","page":"Encoders","title":"FlyRL.VectorEncoder","text":"VectorEncoder(encoders; T, dropmissing, intercept)\n\n\nEncode multiple encodings in a single vector. Categorical encoders are one-hot encoded.\n\nExample\n\nencode(VectorEncoder(ShockArmEncoder(), SpeedEncoder()), random_track(N = 10)) |> DataFrame\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.VelocityEncoder","page":"Encoders","title":"FlyRL.VelocityEncoder","text":"VelocityEncoder()\n\nEncodes velocities based on Δx, Δy and Δt.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.EightWallsEncoder-Tuple{}","page":"Encoders","title":"FlyRL.EightWallsEncoder","text":"EightWallsEncoder(; max_distance = 40, scale = max_distance, stepsize = 1.5)\n\nEncodes (x, y, ox, oy)-position-orientation tuples to relative distances to the next wall at 0, 45, 90, 135, 180, 225, 270 and 315 degrees relative to the orientation.\n\nIf the distance of the wall is max_distance and scale == max_distance the returned value is 1. The stepsize (in pixels) controls the granularity at which the distance to the wall is computed.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.FourWallsEncoder-Tuple{}","page":"Encoders","title":"FlyRL.FourWallsEncoder","text":"FourWallsEncoder(; max_distance = 40, scale = max_distance, stepsize = 1.5)\n\nEncodes (x, y, ox, oy)-position-orientation tuples to relative distances to the next wall at 0, 90, 180 and 270 degrees relative to the orientation.\n\nIf the distance of the wall is max_distance and scale == max_distance the returned value is 1. The stepsize (in pixels) controls the granularity at which the distance to the wall is computed.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.SixWallsEncoder-Tuple{}","page":"Encoders","title":"FlyRL.SixWallsEncoder","text":"SixWallsEncoder(; max_distance = 40, scale = max_distance, stepsize = 1.5)\n\nEncodes (x, y, ox, oy)-position-orientation tuples to relative distances to the next wall at 0, 45, 135, 180, 225 and 315 degrees relative to the orientation.\n\nIf the distance of the wall is max_distance and scale == max_distance the returned value is 1. The stepsize (in pixels) controls the granularity at which the distance to the wall is computed.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.decode-Tuple{FlyRL.VectorEncoder, Any}","page":"Encoders","title":"FlyRL.decode","text":"decode(e, vectors)\n\n\nInverse of encode(VectorEncoder(), track).\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.encode!-Tuple{Any, DataFrames.DataFrame}","page":"Encoders","title":"FlyRL.encode!","text":"Encode track with encoder and store result in data frame track.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.encode-Tuple{Any, DataFrames.DataFrame}","page":"Encoders","title":"FlyRL.encode","text":"Encode track with encoder.\n\n\n\n\n\n","category":"method"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Modules = [FlyRL]\nPages = [\"fitting.jl\"]","category":"page"},{"location":"fitting/#FlyRL.train","page":"Fitting","title":"FlyRL.train","text":"train(model, data)\ntrain(model, data, params; kwargs...)\n\n\nTrain a model to a multiple data frames data with initial parameters params (=params(model) by default).\n\n\n\n\n\n","category":"function"},{"location":"fitting/#FlyRL.train-2","page":"Fitting","title":"FlyRL.train","text":"train(model, data)\ntrain(\n    model,\n    data,\n    params;\n    multi_threading,\n    nthreads,\n    kwargs...\n)\n\n\nTrain a model to a single data frame data with initial parameters params (=params(model) by default).\n\n\n\n\n\n","category":"function"},{"location":"fitting/#FlyRL.train-3","page":"Fitting","title":"FlyRL.train","text":"train(agent, data)\ntrain(\n    agent,\n    data,\n    params;\n    epochs,\n    verbosity,\n    opt,\n    print_interval,\n    lopt,\n    maxtime,\n    optim_options,\n    maxeval,\n    lb,\n    ub,\n    fixed,\n    batchsize\n)\n\n\nTrain agent on preprocessed data with initial parameters params (=params(model) by default).\n\nKeep the default opt = :MLSL for small scale problems and set opt = Adam(), batchsize = 32, if training on minibatches of size 32 is desired. Fix parameter values with e.g. fixed = (; η = 0.). Gradient evaluation is multi-threaded, if julia is started with multiple threads, e.g. bash> julia -t8.\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Models","title":"Models","text":"Modules = [FlyRL]\nPages = [\"models.jl\", \"mdp.jl\"]","category":"page"},{"location":"models/#FlyRL.DeltaPositionModel-Tuple{}","page":"Models","title":"FlyRL.DeltaPositionModel","text":"DeltaPositionModel(\n;\n    nhidden,\n    σ,\n    T,\n    dx,\n    dy,\n    f,\n    encoder,\n    kwargs...\n)\n\n\nMake a DeltaPositionModel.\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.Model","page":"Models","title":"FlyRL.Model","text":"Model(agent, preprocessor)\n\nMakes a model.\n\n\n\n\n\n","category":"type"},{"location":"models/#FlyRL.PolicyGradientAgent-Tuple{}","page":"Models","title":"FlyRL.PolicyGradientAgent","text":"PolicyGradientAgent(; Din, Dout, T, model, update_lag)\n\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.StationaryAgent-Tuple{}","page":"Models","title":"FlyRL.StationaryAgent","text":"StationaryAgent(; Dout, model, T)\n\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.logprob-Tuple{FlyRL.Model, DataFrames.DataFrame, Any}","page":"Models","title":"FlyRL.logprob","text":"logprob(model, data, params)\n\n\nCompute the log-probability of the data given the model with parameters params.\n\n\n\n\n\n","category":"method"},{"location":"detailed_model/#Fitting-a-static-model-to-the-raw-data","page":"Detailed Model","title":"Fitting a static model to the raw data","text":"","category":"section"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"We load the same data as in the previous example. But this time we intend to simulated the actual movement of the fly in densly discretized time and space.","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"using FlyRL, DataFrames\nimport FlyRL: read_directory, plot_track\n\ntracks = FlyRL.read_directory(\"data/dgrp_362/dgrp362_shock\",\n                              drop_outliers = true,\n                              pattern = r\"^track\",\n                              warn_outliers = false);","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"We will use a model, where the probability of moving to a neighbouring x-y-position depends on the speed, the angle relative to the current orientation, previous speed and angle and the distances to the next walls. This probability will be parameterized by a simple feedforward neural network with one hidden layer of 32 neurons.","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"import FlyRL: Preprocessor, VectorEncoder, ColumnPicker, DeltaPositionEncoder,\n              FutureDeltaTimeEncoder, MarkovKEncoder, OrientationEncoder, SpeedEncoder,\n              AngleEncoder, DeltaPositionIndexEncoder\nimport FlyRL: Model, StationaryAgent, DeltaPositionModel, MLP, DenseLayer\n\npreprocessor = Preprocessor(input = VectorEncoder(ColumnPicker(:x),\n                                                  ColumnPicker(:y),\n                                                  DeltaPositionEncoder(),\n                                                  FutureDeltaTimeEncoder(),\n                                                  MarkovKEncoder(2, SpeedEncoder()),\n                                                  MarkovKEncoder(2, AngleEncoder()),\n                                                  MarkovKEncoder(2, OrientationEncoder())),\n                            target = DeltaPositionIndexEncoder());\nmodel = Model(StationaryAgent(Dout = length(preprocessor.target.lookup),\n                              model = DeltaPositionModel(f = MLP(DenseLayer(17, 32, tanh),\n                                                                 DenseLayer(32, 1, identity)))),\n              preprocessor);","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"We will fit this model to the data from the following track (Image: )","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"For fitting we start julia with multiple threads, e.g. julia -t8 re-run the code above, split the data of the last track into 8 junks (first line below), and use the Adam optimizer to fit the data for 6 hours.","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"data = [tracks[end][i*nrow(tracks[end])÷8+1:(i+1)*nrow(tracks[end])÷8, :] for i in 0:7];\nopt = FlyRL.Adam()\nresult = FlyRL.train(model, data, θ, lb = -25, ub = 25,\n                     opt = opt, batchsize = 32,\n                     maxtime = 6*60*60, print_interval = 60)","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"Now we can simulate from the fitted model.","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"import FlyRL: Environment, simulate, in_right\n\nenv = Environment(; preprocessor, shock = in_right);\nenv.state .= preprocess(preprocessor, tracks[end]).input[1]\nx, s, = simulate(model.agent, env, result.params, 10^4);\nsimtrack = FlyRL.decode(preprocessor.input, x) |> DataFrame\nsimtrack.pattern = fill(\"BBG\", nrow(simtrack));\nsimtrack.shock = [s .== 1; false];\nplot_track(simtrack)","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"(Image: )","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"It looks somewhat close to an actual fly track, but the trajectory looks still a bit less smooth than the recordings and the simulated fly seems to spend less time in the turns.","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"We can also have a look at the probabilities of the next action.","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"import FlyRL: plot_delta_pos_probs\n\nplot_delta_pos_probs(model.agent)","category":"page"},{"location":"detailed_model/","page":"Detailed Model","title":"Detailed Model","text":"(Image: ) The white arrow indicates the previous action, the color indicates the log-probability of the next action, where dark red means high probability and white means zero probability. The simulated fly is about to leave the turn in the bottom right. We can see that the fitted model puts low probabilities close to the walls and the highest probabilties are in a cone in almost the same direction as the white arrow.","category":"page"},{"location":"summary_stats/","page":"Summary Statistics","title":"Summary Statistics","text":"Modules = [FlyRL]\nPages = [\"summary_stats.jl\"]","category":"page"},{"location":"summary_stats/#FlyRL.ChangeOf","page":"Summary Statistics","title":"FlyRL.ChangeOf","text":"ChangeOf(stat)\nChangeOf(stat, midpoint)\n\n\nCompute the change in statistics stat before and after the midpoint (= 0.5 by default).\n\nExample\n\nsummarize(ChangeOf(RelativeTimeInShockArm()), track)\n\n\n\n\n\n","category":"type"},{"location":"summary_stats/#FlyRL.RelativeTimeInState-Tuple{Any, Any}","page":"Summary Statistics","title":"FlyRL.RelativeTimeInState","text":"RelativeTimeInState(encoder, state; exclude)\n\n\nCompute the relative duration spent in state in the encoding defined by the encoder. States can be excluded with exclude = [\"state1\", \"state2\"].\n\nExample\n\nsummarize(RelativeTimeInState(SemanticEncoder7(), \"left turn\", exclude = [\"center\"]), track)\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeVisitsToState-Tuple{Any, Any}","page":"Summary Statistics","title":"FlyRL.RelativeVisitsToState","text":"RelativeVisitsToState(e, key; exclude)\n\n\nCompute the relative number of visits to state in the encoding defined by the encoder. States can be excluded with exclude = [\"state1\", \"state2\"].\n\nExample\n\nsummarize(RelativeVisitsToState(SemanticEncoder7(), \"left turn\", exclude = [\"center\"]), track)\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeTimeInShockArm-Tuple{}","page":"Summary Statistics","title":"FlyRL.RelativeTimeInShockArm","text":"RelativeTimeInShockArm()\n\n\nRelative time in shock arm.\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeVisitsToShockArm-Tuple{}","page":"Summary Statistics","title":"FlyRL.RelativeVisitsToShockArm","text":"RelativeVisitsToShockArm()\n\n\nRelative visits to shock arm.\n\n\n\n\n\n","category":"method"},{"location":"#FlyRL","page":"Introduction","title":"FlyRL","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation goes here.","category":"page"},{"location":"abstract_model/#Fitting-a-reinforcement-learning-model-to-an-abstract-representation-of-the-data","page":"Abstract Model","title":"Fitting a reinforcement learning model to an abstract representation of the data","text":"","category":"section"},{"location":"abstract_model/#Loading-the-data","page":"Abstract Model","title":"Loading the data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"This is an example where we first encode the data to an abstract form and then fit a policy gradient reinforcement learning method.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"First we load the data and plot one recording.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"using FlyRL, DataFrames\nimport FlyRL: read_directory, plot_track\n\ntracks = FlyRL.read_directory(\"data/dgrp_362/dgrp362_shock\",\n                              drop_outliers = true,\n                              pattern = r\"^track\",\n                              warn_outliers = false);\n\nplot_track(tracks[end])","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: )","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Blue and green indicate the color of the arm, yellow dots indicate shocks and gray indicates the center of the maze.","category":"page"},{"location":"abstract_model/#Preprocessing-the-data","page":"Abstract Model","title":"Preprocessing the data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Now we define a preprocessor of the raw data.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Preprocessor, ShockArmEncoder, DynamicCompressEncoder, MarkovKEncoder,\n              VectorEncoder, LevelEncoder, preprocess\n\npreprocessor = Preprocessor(input = ShockArmEncoder() |>\n                                    x -> DynamicCompressEncoder(:shock_arm, x) |>\n                                    x -> MarkovKEncoder(2, x) |>\n                                    x -> VectorEncoder(x, intercept = true),\n                                    target = ShockArmEncoder() |> LevelEncoder);\n\ninput, target, shock = preprocess(preprocessor, tracks[end])","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"With this preprocessor, input is a list of vectors with one-hot encoding of the arm, target is a list of levelcodes of the next arm and shock is a list of average number of shocks per time step. Instead of roughly 10^4 time steps as in the raw data tracks[end], the DynamicCompressEncoder compressed the subsequent time steps where the fly was in the same abstract state (e.g. in the shock arm) into one step, such that the input, target and shock sequences have now an approximate length of 50.","category":"page"},{"location":"abstract_model/#Fitting-a-reinforcement-learning-agent","page":"Abstract Model","title":"Fitting a reinforcement learning agent","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Next we define a simple policy gradient agent to fit the data and compute the log-probability of the data given the model and some default parameters that include the discount factor, the learning rate and the initial transition probabilities between abstract states.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Model, PolicyGradientAgent, params, logprob\n\nmodel = Model(PolicyGradientAgent(Din = length(input[1]),\n                                  Dout = length(FlyRL.levels(preprocessor.target.encoder)[1])),\n                                  preprocessor);\nθ = params(model) # some default parameters\nlogprob(model, tracks[end], θ)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us now find the parameters that optimize the log-probability.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: train\nresult = train(model, tracks[end], θ, maxtime = 20, print_interval = 3)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"The log-probability with the fitted parameters is much higher than the value we obtained above.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"logprob(model, tracks[end], result.params)","category":"page"},{"location":"abstract_model/#Generate-simulated-data","page":"Abstract Model","title":"Generate simulated data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"We can now use the fitted model to obtain simulated tracks.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Environment, in_shock_arm, simulate\n\nenv = Environment(; preprocessor, shock = in_shock_arm);\nx, s, a, logp = simulate(model.agent, env, result.params, 50)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"We can look at the simulation result by decoding the states x","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: decode\n\ndecode(preprocessor.input, x) |> DataFrame","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us compare the simulated data to the recorded data","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: plot_compare_probs\n\nplot_compare_probs(decode(preprocessor.input, input).shock_arm,\n                   decode(preprocessor.input, x).shock_arm)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: )","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"The top row shows the visitation counts of the different arms in the recorded data and the bottom row shows them for one simulated trial. The first column shows the visitation counts over the whole trajectory (from relative time 0 to relative time 1). The middle row shows the visitation count for the first half of the trial and the last column shows the visitations counts for the second half. We see that the visitation count of the shock arm went down from the first to the second half, both in the recording (top) and the simulation (bottom). Because the simulations are stochastic, each simulated trial will look different, but on average a reduction of the visits to the shock arm is visible.","category":"page"},{"location":"abstract_model/#Model-fitting-for-data-analysis","page":"Abstract Model","title":"Model-fitting for data analysis","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us fit a few recorded tracks and look at the learning rates and discount factors.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"function fit_lr_and_gamma(model, tracks)\n    η = Float64[]\n    γ = Float64[]\n    for track2fit in tracks\n        θ = params(model)\n        res = train(model, track2fit, θ, maxtime = 10, print_interval = 9)\n        push!(η, res.params.η)\n        push!(γ, FlyRL.sigmoid(res.params.logitγ))\n    end\n    (; η, γ)\nend\nlr_and_gamma = fit_lr_and_gamma(model, tracks) # this may take some time","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"We plot now some summary statistics of the data, together with the fitted parameters.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: plot_summaries\nimport FlyRL: RelativeVisitsToShockArm, RelativeTimeInShockArm, ChangeOf\nusing CairoMakie\n\nfunction plot_stats_and_fits(tracks, lr_and_gamma;\n        summaries = (RelativeTimeInShockArm(), ChangeOf(RelativeTimeInShockArm()),\n                     RelativeVisitsToShockArm(), ChangeOf(RelativeVisitsToShockArm())),\n        f = Figure(resolution = (1000, 400)))\n    sp = sortperm(lr_and_gamma.η)\n    plot_summaries(tracks; f, sortperm = sp, summaries)\n    ax = Axis(f[1, length(summaries) + 1], ylabel = \"sign(η) ⋅ log(1 + |η|)\", xlabel = \"track id\")\n    scatter!(ax, eachindex(lr_and_gamma.η), sign.(lr_and_gamma.η[sp]) .* log.(1 .+ abs.(lr_and_gamma.η[sp])))\n    hlines!(ax, 0.)\n    ax = Axis(f[1, length(summaries) + 2], ylabel = \"γ\", xlabel = \"track id\")\n    scatter!(ax, eachindex(lr_and_gamma.γ), lr_and_gamma.γ[sp])\n    f\nend\nplot_stats_and_fits(tracks, lr_and_gamma)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: ) The tracks are sorted by ascending learning rate (5th panel). Not surprisingly, the learning rate seems to correlate with the change of relative visits to the shock arm. There is no obvious pattern for the discount factor gamma.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"The largest learning rate was obtained for a track, where the shocked arm was visited once and never again. (Image: )","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"A negative learning rate was obtained for a track where the fly alternated only between one neutral arm and the shock arm. Note that the simple abstract model we are using here is not capable of capturing the longer durations spent in the neutral arm. (Image: )","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Do the differences in learning rate (or other statistics) indicate that there are fundamental differences between the different flies, or could N copies of the exact same fly lead to the same observed differences in learning rates etc., simply because action selection is random and the trials are of limited length? In simulations we can create multiple runs of the exact same model and only vary the initial conditions and the seed of the pseudo-random number generator. In the following we use the fitted parameters found in Fitting a reinforcement learning agent and we simulate tracks that have the same duration as the recorded tracks.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"function simulated_tracks(model, env, θ, Ts)\n    res = []\n    for T in Ts\n        x, s, = simulate(model.agent, env, θ, T)\n        df = decode(model.preprocessor.input, x[2:end]) |> DataFrame\n        df.shock = s\n        push!(res, select(df, [:shock_arm, :shock]))\n    end\n    res\nend\nTs = length.(first.(preprocess.(Ref(preprocessor), tracks)))\nsim_tracks = simulated_tracks(model, env, result.params, Ts)\nsim_lr_and_gamma = fit_lr_and_gamma(model, sim_tracks) # this may take some time\nplot_stats_and_fits(sim_tracks, sim_lr_and_gamma,\n        summaries = (RelativeVisitsToShockArm(), ChangeOf(RelativeVisitsToShockArm())))","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: ) We see indeed a large variability between different simulated runs with exactly the same model. Note that we do not plot the relative time spent in the shock arm, because our abstract model does not simulate the durations spent in each arm.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Could we even get similar behaviour, if the learning rate were 0?","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"newparams = copy(result.params)\nnewparams.η = 0.\nsim_tracks2 = simulated_tracks(model, env, newparams, Ts)\nsim_lr_and_gamma2 = fit_lr_and_gamma(model, sim_tracks2) # this may take some time\nplot_stats_and_fits(sim_tracks2, sim_lr_and_gamma2,\n        summaries = (RelativeVisitsToShockArm(), ChangeOf(RelativeVisitsToShockArm())))","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: ) One does indeed get similar differences between the different simulated tracks. In contrast to the simulations with positive learning rates, however, many fitted learning rates are close to zero and there is roughly an equal number of strongly positive and strongly negative learning rates.","category":"page"},{"location":"io/","page":"Loading Files","title":"Loading Files","text":"Utility functions for loading raw data.","category":"page"},{"location":"io/","page":"Loading Files","title":"Loading Files","text":"Modules = [FlyRL]\nPages = [\"io.jl\"]","category":"page"},{"location":"io/#FlyRL.preprocess-Tuple{Any}","page":"Loading Files","title":"FlyRL.preprocess","text":"preprocess(\n    df;\n    filter,\n    window,\n    initial_outlier_tolerance,\n    encoders,\n    warn_outliers,\n    drop_outliers,\n    subsample_resolution\n)\n\n\nPreprocess data frame df.\n\n\n\n\n\n","category":"method"},{"location":"io/#FlyRL.read-Tuple{Any, Any}","page":"Loading Files","title":"FlyRL.read","text":"read(root, f; preprocess, kwargs...)\n\n\nRead track f in directory root and corresponding time, shock and pattern file. Returns a DataFrame. kwargs are passed to preprocess.\n\n\n\n\n\n","category":"method"},{"location":"io/#FlyRL.read_directory-Tuple{Any}","page":"Loading Files","title":"FlyRL.read_directory","text":"read_directory(dir; verbosity, pattern, kwargs...)\n\n\nRead all tracks in directory dir. Uses read and passes kwargs to preprocess.\n\n\n\n\n\n","category":"method"}]
}
