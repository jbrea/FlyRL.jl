var documenterSearchIndex = {"docs":
[{"location":"simulations/","page":"Simulations","title":"Simulations","text":"Modules = [FlyRL]\nPages = [\"simulators.jl\"]","category":"page"},{"location":"simulations/#FlyRL.Environment","page":"Simulations","title":"FlyRL.Environment","text":"Environment(; preprocessor,\n              pattern = \"GBB\",\n              shock = shock_function(pattern),\n              state = rand_state(preprocessor, pattern, shock))\n\nDefine an environment that can be used for simulations.\n\n\n\n\n\n","category":"type"},{"location":"simulations/#FlyRL.random_track-Tuple{}","page":"Simulations","title":"FlyRL.random_track","text":"random_track(; N, pattern, shock)\n\n\n\n\n\n\n","category":"method"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Encoders can be used to transform the raw data in different ways. This can be done in two ways, illustrated here with the ShockArmEncoder:","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Create a new data frame with the transformed data","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"using DataFrames\nimport FlyRL: encode, ShockArmEncoder, random_track\ntrack = random_track(N = 100)\nencode(ShockArmEncoder(), track) |> DataFrame","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Append the transformed data directly to the original data frame","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"using DataFrames\nimport FlyRL: encode!, ShockArmEncoder, random_track\ntrack = random_track(N = 100)\nencode!(ShockArmEncoder(), track)","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Here is a list of built-in encoders.","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Modules = [FlyRL]\nPages = [\"encoders.jl\"]","category":"page"},{"location":"encoders/#FlyRL.AngleEncoder","page":"Encoders","title":"FlyRL.AngleEncoder","text":"AngleEncoder()\n\nEncodes angles between subsequent orientations.\n\nConvention: the same row should contain the delta values that lead to the current value, i.e. delta values should start with missing.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.AngleEncoder2D","page":"Encoders","title":"FlyRL.AngleEncoder2D","text":"AngleEncoder2D()\n\nEncodes angles as (sin(angle), cos(angle)) (see also AngleEncoder).\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.ArmEncoder-Tuple{}","page":"Encoders","title":"FlyRL.ArmEncoder","text":"ArmEncoder(; with_outliers)\n\n\nEncodes arms of the maze as \"left\", \"middle\", \"right\", \"center\". Points outside the maze are marked as \"outlier\" if with_outliers = true.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.ClosestWallEncoder","page":"Encoders","title":"FlyRL.ClosestWallEncoder","text":"ClosestWallEncoder(encoder)\n\nEncodes the closest wall as determined with encoder (either FourWallsEncoder, SixWallsEncoder or EightWallsEncoder).\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.ColorEncoder-Tuple{}","page":"Encoders","title":"FlyRL.ColorEncoder","text":"ColorEncoder(; colordict, with_outliers)\n\n\nEncode color based on track.pattern.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.ColumnPicker","page":"Encoders","title":"FlyRL.ColumnPicker","text":"ColumnPicker(colname::Symbol)\n\nPicks a column from a data frame.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DeltaPositionEncoder","page":"Encoders","title":"FlyRL.DeltaPositionEncoder","text":"DeltaPositionEncoder()\n\nEncodes Δx and Δy from x and y.\n\nConvention: the same row should contain the delta values that lead to the current value, i.e. delta values should start with missing.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DeltaPositionIndexEncoder","page":"Encoders","title":"FlyRL.DeltaPositionIndexEncoder","text":"DeltaPositionIndexEncoder(; maxradius = 20, stepsize = 1)\n\nEncodes relative positions (Δx, Δy) with an integer, based on a 2D grid with stepsize and largest relative position Δx^2 + Δy^2 = maxradius^2.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DeltaTimeEncoder","page":"Encoders","title":"FlyRL.DeltaTimeEncoder","text":"DeltaTimeEncoder()\n\nEncodes Δt from t; uses default 0.15, if t is missing.\n\nConvention: the same row should contain the delta values that lead to the current value, i.e. delta values should start with missing.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DurationPerStateEncoder","page":"Encoders","title":"FlyRL.DurationPerStateEncoder","text":"DurationPerStateEncoder(encoder)\n\nEncode the duration that is spent in a given state.\n\nExample\n\nencode(DurationPerStateEncoder(ShockArmEncoder()), random_track()) |> DataFrame\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.DynamicCompressEncoder-Union{Tuple{N}, Tuple{Union{Symbol, Tuple{Vararg{Symbol, N}}}, Vararg{Any}}} where N","page":"Encoders","title":"FlyRL.DynamicCompressEncoder","text":"DynamicCompressEncoder(compress_on, encoders...)\n\nMerge subsequent states of compress_on into one state.\n\nExample\n\nencode(DynamicCompressEncoder(StanHMCAdaptor()), random_track()) |> DataFrame\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.FutureDeltaTimeEncoder","page":"Encoders","title":"FlyRL.FutureDeltaTimeEncoder","text":"FutureDeltaTimeEncoder()\n\nSame as DeltaTimeEncoder but offset by one, i.e. the same row contains the delta value that leads to the next value.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.InShockArmEncoder","page":"Encoders","title":"FlyRL.InShockArmEncoder","text":"InShockArmEncoder()\n\nEncodes if the position is in the shock arm.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.LevelEncoder","page":"Encoders","title":"FlyRL.LevelEncoder","text":"LevelEncoder(encoder)\n\nEncode level as an integer for a categorical encoder (like ShockArmEncoder).\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.MarkovKEncoder-Tuple{Any, Vararg{Any}}","page":"Encoders","title":"FlyRL.MarkovKEncoder","text":"MarkovKEncoder(K, encoders)\n\n\nCreate copies of the original encoders with offsets up to K. Appends ˌk to copy with offset k.\n\nExample\n\nencode(MarkovKEncoder(3, DynamicCompressEncoder(:arm, ArmEncoder())), random_track()) |> DataFrame\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.OrientationEncoder","page":"Encoders","title":"FlyRL.OrientationEncoder","text":"OrientationEncoder()\n\nEncodes orientations based on Δx and Δy.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.SemanticEncoder3-Tuple{}","page":"Encoders","title":"FlyRL.SemanticEncoder3","text":"SemanticEncoder3(; with_outliers)\n\n\nEncodes positions of the maze as \"center\", \"arm\" or \"turn\". Points outside the maze are marked as \"outlier\" if with_outliers = true.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.SemanticEncoder7-Tuple{}","page":"Encoders","title":"FlyRL.SemanticEncoder7","text":"SemanticEncoder7(; with_outliers)\n\n\nEncodes positions of the maze as \"center\", \"left arm\", \"left turn\", \"middle arm\", \"middle turn\", \"right arm\", \"right turn\". Points outside the maze are marked as \"outlier\" if with_outliers = true.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.ShockArmEncoder-Tuple{}","page":"Encoders","title":"FlyRL.ShockArmEncoder","text":"ShockArmEncoder(; with_outliers)\n\n\nEncodes arms of the maze as \"neutral A\", \"neutral B\", \"shock\" and \"center\". Points outside the maze are marked as \"outlier\" if with_outliers = true.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.SpeedEncoder-Tuple{}","page":"Encoders","title":"FlyRL.SpeedEncoder","text":"SpeedEncoder(; outlier_threshold, return_outliers)\n\n\nEncode the speed based on vx and vy (see VelocityEncoder). Speed values above outlier_threshold are returned as missing. If return_outliers = true, return also a vector of outlier values.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.VectorEncoder-Tuple","page":"Encoders","title":"FlyRL.VectorEncoder","text":"VectorEncoder(encoders; T, dropmissing, intercept)\n\n\nEncode multiple encodings in a single vector. Categorical encoders are one-hot encoded.\n\nExample\n\nencode(VectorEncoder(ShockArmEncoder(), SpeedEncoder()), random_track(N = 10)) |> DataFrame\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.VelocityEncoder","page":"Encoders","title":"FlyRL.VelocityEncoder","text":"VelocityEncoder()\n\nEncodes velocities based on Δx, Δy and Δt.\n\n\n\n\n\n","category":"type"},{"location":"encoders/#FlyRL.EightWallsEncoder-Tuple{}","page":"Encoders","title":"FlyRL.EightWallsEncoder","text":"EightWallsEncoder(; max_distance = 40, scale = max_distance, stepsize = 1.5)\n\nEncodes (x, y, ox, oy)-position-orientation tuples to relative distances to the next wall at 0, 45, 90, 135, 180, 225, 270 and 315 degrees relative to the orientation.\n\nIf the distance of the wall is max_distance and scale == max_distance the returned value is 1. The stepsize (in pixels) controls the granularity at which the distance to the wall is computed.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.FourWallsEncoder-Tuple{}","page":"Encoders","title":"FlyRL.FourWallsEncoder","text":"FourWallsEncoder(; max_distance = 40, scale = max_distance, stepsize = 1.5)\n\nEncodes (x, y, ox, oy)-position-orientation tuples to relative distances to the next wall at 0, 90, 180 and 270 degrees relative to the orientation.\n\nIf the distance of the wall is max_distance and scale == max_distance the returned value is 1. The stepsize (in pixels) controls the granularity at which the distance to the wall is computed.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.SixWallsEncoder-Tuple{}","page":"Encoders","title":"FlyRL.SixWallsEncoder","text":"SixWallsEncoder(; max_distance = 40, scale = max_distance, stepsize = 1.5)\n\nEncodes (x, y, ox, oy)-position-orientation tuples to relative distances to the next wall at 0, 45, 135, 180, 225 and 315 degrees relative to the orientation.\n\nIf the distance of the wall is max_distance and scale == max_distance the returned value is 1. The stepsize (in pixels) controls the granularity at which the distance to the wall is computed.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.decode-Tuple{FlyRL.VectorEncoder, Any}","page":"Encoders","title":"FlyRL.decode","text":"decode(e, vectors)\n\n\nInverse of encode(VectorEncoder(), track).\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.encode!-Tuple{Any, DataFrames.DataFrame}","page":"Encoders","title":"FlyRL.encode!","text":"Encode track with encoder and store result in data frame track.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.encode-Tuple{Any, DataFrames.DataFrame}","page":"Encoders","title":"FlyRL.encode","text":"Encode track with encoder.\n\n\n\n\n\n","category":"method"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Modules = [FlyRL]\nPages = [\"fitting.jl\"]","category":"page"},{"location":"fitting/#FlyRL.train","page":"Fitting","title":"FlyRL.train","text":"train(model, data)\ntrain(model, data, params; kwargs...)\n\n\nTrain a model to a multiple data frames data with initial parameters params (=params(model) by default).\n\n\n\n\n\n","category":"function"},{"location":"fitting/#FlyRL.train-2","page":"Fitting","title":"FlyRL.train","text":"train(model, data)\ntrain(\n    model,\n    data,\n    params;\n    multi_threading,\n    nthreads,\n    kwargs...\n)\n\n\nTrain a model to a single data frame data with initial parameters params (=params(model) by default).\n\n\n\n\n\n","category":"function"},{"location":"fitting/#FlyRL.train-3","page":"Fitting","title":"FlyRL.train","text":"train(agent, data)\ntrain(\n    agent,\n    data,\n    params;\n    epochs,\n    verbosity,\n    opt,\n    print_interval,\n    lopt,\n    maxtime,\n    optim_options,\n    maxeval,\n    lb,\n    ub,\n    fixed,\n    batchsize\n)\n\n\nTrain agent on preprocessed data with initial parameters params (=params(model) by default).\n\nKeep the default opt = :MLSL for small scale problems and set opt = Adam(), batchsize = 32, if training on minibatches of size 32 is desired. Fix parameter values with e.g. fixed = (; η = 0.). Gradient evaluation is multi-threaded, if julia is started with multiple threads, e.g. bash> julia -t8.\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Models","title":"Models","text":"Modules = [FlyRL]\nPages = [\"models.jl\", \"mdp.jl\"]","category":"page"},{"location":"models/#FlyRL.DeltaPositionModel-Tuple{}","page":"Models","title":"FlyRL.DeltaPositionModel","text":"DeltaPositionModel(\n;\n    nhidden,\n    σ,\n    T,\n    dx,\n    dy,\n    f,\n    encoder,\n    kwargs...\n)\n\n\nMake a DeltaPositionModel.\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.Model","page":"Models","title":"FlyRL.Model","text":"Model(agent, preprocessor)\n\nMakes a model.\n\n\n\n\n\n","category":"type"},{"location":"models/#FlyRL.PolicyGradientAgent-Tuple{}","page":"Models","title":"FlyRL.PolicyGradientAgent","text":"PolicyGradientAgent(; Din, Dout, T, model, update_lag)\n\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.StationaryAgent-Tuple{}","page":"Models","title":"FlyRL.StationaryAgent","text":"StationaryAgent(; Dout, model, T)\n\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.logprob-Tuple{FlyRL.Model, DataFrames.DataFrame, Any}","page":"Models","title":"FlyRL.logprob","text":"logprob(model, data, params)\n\n\nCompute the log-probability of the data given the model with parameters params.\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/","page":"Summary Statistics","title":"Summary Statistics","text":"Modules = [FlyRL]\nPages = [\"summary_stats.jl\"]","category":"page"},{"location":"summary_stats/#FlyRL.ChangeOf","page":"Summary Statistics","title":"FlyRL.ChangeOf","text":"ChangeOf(stat)\nChangeOf(stat, midpoint)\n\n\nCompute the change in statistics stat before and after the midpoint (= 0.5 by default).\n\nExample\n\nsummarize(ChangeOf(RelativeTimeInShockArm()), track)\n\n\n\n\n\n","category":"type"},{"location":"summary_stats/#FlyRL.RelativeTimeInState-Tuple{Any, Any}","page":"Summary Statistics","title":"FlyRL.RelativeTimeInState","text":"RelativeTimeInState(encoder, state; exclude)\n\n\nCompute the relative duration spent in state in the encoding defined by the encoder. States can be excluded with exclude = [\"state1\", \"state2\"].\n\nExample\n\nsummarize(RelativeTimeInState(SemanticEncoder7(), \"left turn\", exclude = [\"center\"]), track)\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeVisitsToState-Tuple{Any, Any}","page":"Summary Statistics","title":"FlyRL.RelativeVisitsToState","text":"RelativeVisitsToState(e, key; exclude)\n\n\nCompute the relative number of visits to state in the encoding defined by the encoder. States can be excluded with exclude = [\"state1\", \"state2\"].\n\nExample\n\nsummarize(RelativeVisitsToState(SemanticEncoder7(), \"left turn\", exclude = [\"center\"]), track)\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeTimeInShockArm-Tuple{}","page":"Summary Statistics","title":"FlyRL.RelativeTimeInShockArm","text":"RelativeTimeInShockArm()\n\n\nRelative time in shock arm.\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeVisitsToShockArm-Tuple{}","page":"Summary Statistics","title":"FlyRL.RelativeVisitsToShockArm","text":"RelativeVisitsToShockArm()\n\n\nRelative visits to shock arm.\n\n\n\n\n\n","category":"method"},{"location":"#FlyRL","page":"Introduction","title":"FlyRL","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation goes here.","category":"page"},{"location":"abstract_model/#Fitting-an-reinforcement-learning-model-to-an-abstract-representation-of-the-data","page":"Abstract Model","title":"Fitting an reinforcement learning model to an abstract representation of the data","text":"","category":"section"},{"location":"abstract_model/#Loading-the-data","page":"Abstract Model","title":"Loading the data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"This is an example where we first encode the data to an abstract form and then fit a policy gradient reinforcement learning method.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"First we load the data and plot one recording.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"using FlyRL, DataFrames\nimport FlyRL: read_directory, plot_track\n\ntracks = FlyRL.read_directory(\"data/dgrp_362/dgrp362_shock\",\n                              drop_outliers = true,\n                              pattern = r\"^track\",\n                              warn_outliers = false);\n\nplot_track(tracks[end])","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: )","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Blue and green indicate the color of the arm, yellow dots indicate shocks and gray indicates the center of the maze.","category":"page"},{"location":"abstract_model/#Preprocessing-the-data","page":"Abstract Model","title":"Preprocessing the data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Now we define a preprocessor of the raw data.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Preprocessor, ShockArmEncoder, DynamicCompressEncoder, MarkovKEncoder,\n              VectorEncoder, LevelEncoder, preprocess\n\npreprocessor = Preprocessor(input = ShockArmEncoder() |>\n                                    x -> DynamicCompressEncoder(:shock_arm, x) |>\n                                    x -> MarkovKEncoder(2, x) |>\n                                    x -> VectorEncoder(x, intercept = true),\n                                    target = ShockArmEncoder() |> LevelEncoder);\n\ninput, target, shock = preprocess(preprocessor, tracks[end])","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"With this preprocessor, input is a list of vectors with one-hot encoding of the arm, target is a list of levelcodes of the next arm and shock is a list of average number of shocks per time step. Instead of roughly 10^4 time steps as in the raw data tracks[end], the DynamicCompressEncoder compressed the subsequent time steps where the fly was in the same abstract state (e.g. in the shock arm) into one step, such that the input, target and shock sequences have now an approximate length of 50.","category":"page"},{"location":"abstract_model/#Fit-a-reinforcement-learning-agent","page":"Abstract Model","title":"Fit a reinforcement learning agent","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Next we define a simple policy gradient agent to fit the data and compute the log-probability of the data given the model and some default parameters that include the discount factor, the learning rate and the initial transition probabilities between abstract states.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Model, PolicyGradientAgent, params, logprob\n\nmodel = Model(PolicyGradientAgent(Din = length(input[1]),\n                                  Dout = length(FlyRL.levels(preprocessor.target.encoder)[1])),\n                                  preprocessor);\nθ = params(model) # some default parameters\nlogprob(model, tracks[end], θ)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us now find the parameters that optimize the log-probability.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: train\nresult = train(model, tracks[end], θ, maxtime = 20, print_interval = 3)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"The log-probability with the fitted parameters is much higher than the value we obtained above.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"logprob(model, tracks[end], result.params)","category":"page"},{"location":"abstract_model/#Generate-simulated-data","page":"Abstract Model","title":"Generate simulated data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"We can now use the fitted model to obtain simulated tracks.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Environment, in_shock_arm, simulate\n\nenv = Environment(; preprocessor, shock = in_shock_arm);\nx, s, a, logp = simulate(model.agent, env, result.params, 50)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"We can look at the simulation result by decoding the states x","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: decode\n\ndecode(preprocessor.input, x) |> DataFrame","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us compare the simulated data to the recorded data","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: plot_compare_probs\n\nplot_compare_probs(decode(preprocessor.input, input).shock_arm,\n                   decode(preprocessor.input, x).shock_arm)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: )","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"The top row shows the visitation counts of the different arms in the recorded data and the bottom row shows them for one simulated trial. The first column shows the visitation counts over the whole trajectory (from relative time 0 to relative time 1). The middle row shows the visitation count for the first half of the trial and the last column shows the visitations counts for the second half. We see that the visitation count of the shock arm went down from the first to the second half, both in the recording (top) and the simulation (bottom). Because the simulations are stochastic, each simulated trial will look different, but on average a reduction of the visits to the shock arm is visible.","category":"page"},{"location":"abstract_model/#Model-fitting-for-data-analysis","page":"Abstract Model","title":"Model-fitting for data analysis","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us fit a few recorded tracks and look at the learning rates and discount factors.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"function fit_lr_and_gamma(model, tracks)\n    η = Float64[]\n    γ = Float64[]\n    for track2fit in tracks\n        θ = params(model)\n        res = train(model, track2fit, θ, maxtime = 20, print_interval = 10)\n        push!(η, res.params.η)\n        push!(γ, FlyRL.sigmoid(res.params.logitγ))\n    end\n    (; η, γ)\nend\nresult = fit_lr_and_gamma(model, tracks)","category":"page"},{"location":"io/","page":"Loading Files","title":"Loading Files","text":"Utility functions for loading raw data.","category":"page"},{"location":"io/","page":"Loading Files","title":"Loading Files","text":"Modules = [FlyRL]\nPages = [\"io.jl\"]","category":"page"},{"location":"io/#FlyRL.preprocess-Tuple{Any}","page":"Loading Files","title":"FlyRL.preprocess","text":"preprocess(\n    df;\n    filter,\n    window,\n    initial_outlier_tolerance,\n    encoders,\n    warn_outliers,\n    drop_outliers,\n    subsample_resolution\n)\n\n\nPreprocess data frame df.\n\n\n\n\n\n","category":"method"},{"location":"io/#FlyRL.read-Tuple{Any, Any}","page":"Loading Files","title":"FlyRL.read","text":"read(root, f; preprocess, kwargs...)\n\n\nRead track f in directory root and corresponding time, shock and pattern file. Returns a DataFrame. kwargs are passed to preprocess.\n\n\n\n\n\n","category":"method"},{"location":"io/#FlyRL.read_directory-Tuple{Any}","page":"Loading Files","title":"FlyRL.read_directory","text":"read_directory(dir; verbosity, pattern, kwargs...)\n\n\nRead all tracks in directory dir. Uses read and passes kwargs to preprocess.\n\n\n\n\n\n","category":"method"}]
}
