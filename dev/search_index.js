var documenterSearchIndex = {"docs":
[{"location":"simulations/","page":"Simulations","title":"Simulations","text":"Modules = [FlyRL]\nPages = [\"simulations.md\"]","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Encoders can be used to transform the raw data in different ways. This can be done in two ways, illustrated here with the ShockArmEncoder:","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Create a new data frame with the transformed data","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"using DataFrames\nimport FlyRL: encode, ShockArmEncoder, random_track\ntrack = random_track(N = 100)\nencode(ShockArmEncoder(), track) |> DataFrame","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Append the transformed data directly to the original data frame","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"using DataFrames\nimport FlyRL: encode!, ShockArmEncoder, random_track\ntrack = random_track(N = 100)\nencode!(ShockArmEncoder(), track)","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Here is a list of built-in encoders.","category":"page"},{"location":"encoders/","page":"Encoders","title":"Encoders","text":"Modules = [FlyRL]\nPages = [\"io.jl\"]","category":"page"},{"location":"encoders/#FlyRL.preprocess-Tuple{Any}","page":"Encoders","title":"FlyRL.preprocess","text":"preprocess(\n    df;\n    filter,\n    window,\n    initial_outlier_tolerance,\n    encoders,\n    warn_outliers,\n    drop_outliers,\n    subsample_resolution\n)\n\n\nPreprocess data frame df.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.read-Tuple{Any, Any}","page":"Encoders","title":"FlyRL.read","text":"read(root, f; preprocess, kwargs...)\n\n\nRead track f in directory root and corresponding time, shock and pattern file. Returns a DataFrame. kwargs are passed to preprocess.\n\n\n\n\n\n","category":"method"},{"location":"encoders/#FlyRL.read_directory-Tuple{Any}","page":"Encoders","title":"FlyRL.read_directory","text":"read_directory(dir; verbosity, pattern, kwargs...)\n\n\nRead all tracks in directory dir. Uses read and passes kwargs to preprocess.\n\n\n\n\n\n","category":"method"},{"location":"fitting/","page":"Fitting","title":"Fitting","text":"Modules = [FlyRL]\nPages = [\"fitting.jl\"]","category":"page"},{"location":"fitting/#FlyRL.train","page":"Fitting","title":"FlyRL.train","text":"train(model, data)\ntrain(\n    model,\n    data,\n    params;\n    multi_threading,\n    nthreads,\n    kwargs...\n)\n\n\nTrain a model to a single data frame data with initial parameters params (=params(model) by default).\n\n\n\n\n\n","category":"function"},{"location":"fitting/#FlyRL.train-2","page":"Fitting","title":"FlyRL.train","text":"train(model, data)\ntrain(model, data, params; kwargs...)\n\n\nTrain a model to a multiple data frames data with initial parameters params (=params(model) by default).\n\n\n\n\n\n","category":"function"},{"location":"fitting/#FlyRL.train-3","page":"Fitting","title":"FlyRL.train","text":"train(agent, data)\ntrain(\n    agent,\n    data,\n    params;\n    epochs,\n    verbosity,\n    opt,\n    print_interval,\n    lopt,\n    maxtime,\n    optim_options,\n    maxeval,\n    lb,\n    ub,\n    fixed,\n    batchsize\n)\n\n\nTrain agent on preprocessed data with initial parameters params (=params(model) by default).\n\nKeep the default opt = :MLSL for small scale problems and set opt = Adam(), batchsize = 32, if training on minibatches of size 32 is desired. Fix parameter values with e.g. fixed = (; η = 0.). Gradient evaluation is multi-threaded, if julia is started with multiple threads, e.g. bash> julia -t8.\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Models","title":"Models","text":"Modules = [FlyRL]\nPages = [\"models.jl\", \"mdp.jl\"]","category":"page"},{"location":"models/#FlyRL.DeltaPositionModel-Tuple{}","page":"Models","title":"FlyRL.DeltaPositionModel","text":"DeltaPositionModel(\n;\n    nhidden,\n    σ,\n    T,\n    dx,\n    dy,\n    f,\n    encoder,\n    kwargs...\n)\n\n\nMake a DeltaPositionModel.\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.Model","page":"Models","title":"FlyRL.Model","text":"Model(agent, preprocessor)\n\nMakes a model.\n\n\n\n\n\n","category":"type"},{"location":"models/#FlyRL.PolicyGradientAgent-Tuple{}","page":"Models","title":"FlyRL.PolicyGradientAgent","text":"PolicyGradientAgent(; Din, Dout, T, model, update_lag)\n\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.StationaryAgent-Tuple{}","page":"Models","title":"FlyRL.StationaryAgent","text":"StationaryAgent(; Dout, model, T)\n\n\n\n\n\n\n","category":"method"},{"location":"models/#FlyRL.logprob-Tuple{FlyRL.Model, DataFrames.DataFrame, Any}","page":"Models","title":"FlyRL.logprob","text":"logprob(model, data, params)\n\n\nCompute the log-probability of the data given the model with parameters params.\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/","page":"Summary Statistics","title":"Summary Statistics","text":"Modules = [FlyRL]\nPages = [\"summary_stats.jl\"]","category":"page"},{"location":"summary_stats/#FlyRL.ChangeOf","page":"Summary Statistics","title":"FlyRL.ChangeOf","text":"ChangeOf(stat)\nChangeOf(stat, midpoint)\n\n\nCompute the change in statistics stat before and after the midpoint (= 0.5 by default).\n\nExample\n\nsummarize(ChangeOf(RelativeTimeInShockArm()), track)\n\n\n\n\n\n","category":"type"},{"location":"summary_stats/#FlyRL.RelativeTimeInState-Tuple{Any, Any}","page":"Summary Statistics","title":"FlyRL.RelativeTimeInState","text":"RelativeTimeInState(encoder, state; exclude)\n\n\nCompute the relative duration spent in state in the encoding defined by the encoder. States can be excluded with exclude = [\"state1\", \"state2\"].\n\nExample\n\nsummarize(RelativeTimeInState(SemanticEncoder7(), \"left turn\", exclude = [\"center\"]), track)\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeVisitsToState-Tuple{Any, Any}","page":"Summary Statistics","title":"FlyRL.RelativeVisitsToState","text":"RelativeVisitsToState(e, key; exclude)\n\n\nCompute the relative number of visits to state in the encoding defined by the encoder. States can be excluded with exclude = [\"state1\", \"state2\"].\n\nExample\n\nsummarize(RelativeVisitsToState(SemanticEncoder7(), \"left turn\", exclude = [\"center\"]), track)\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeTimeInShockArm-Tuple{}","page":"Summary Statistics","title":"FlyRL.RelativeTimeInShockArm","text":"RelativeTimeInShockArm()\n\n\nRelative time in shock arm.\n\n\n\n\n\n","category":"method"},{"location":"summary_stats/#FlyRL.RelativeVisitsToShockArm-Tuple{}","page":"Summary Statistics","title":"FlyRL.RelativeVisitsToShockArm","text":"RelativeVisitsToShockArm()\n\n\nRelative visits to shock arm.\n\n\n\n\n\n","category":"method"},{"location":"#FlyRL","page":"Introduction","title":"FlyRL","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation goes here.","category":"page"},{"location":"abstract_model/#Fitting-an-reinforcement-learning-model-to-an-abstract-representation-of-the-data","page":"Abstract Model","title":"Fitting an reinforcement learning model to an abstract representation of the data","text":"","category":"section"},{"location":"abstract_model/#Loading-the-data","page":"Abstract Model","title":"Loading the data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"This is an example where we first encode the data to an abstract form and then fit a policy gradient reinforcement learning method.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"First we load the data and plot one recording.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"using FlyRL, DataFrames\nimport FlyRL: read_directory, plot_track\n\ntracks = FlyRL.read_directory(\"data/dgrp_362/dgrp362_shock\",\n                              drop_outliers = true,\n                              pattern = r\"^track\",\n                              warn_outliers = false);\n\nplot_track(tracks[end])","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: )","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Blue and green indicate the color of the arm, yellow dots indicate shocks and gray indicates the center of the maze.","category":"page"},{"location":"abstract_model/#Preprocessing-the-data","page":"Abstract Model","title":"Preprocessing the data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Now we define a preprocessor of the raw data.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Preprocessor, ShockArmEncoder, DynamicCompressEncoder, MarkovKEncoder,\n              VectorEncoder, LevelEncoder, preprocess\n\npreprocessor = Preprocessor(input = ShockArmEncoder() |>\n                                    x -> DynamicCompressEncoder(:shock_arm, x) |>\n                                    x -> MarkovKEncoder(2, x) |>\n                                    x -> VectorEncoder(x, intercept = true),\n                                    target = ShockArmEncoder() |> LevelEncoder);\n\ninput, target, shock = preprocess(preprocessor, tracks[end])","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"With this preprocessor, input is a list of vectors with one-hot encoding of the arm, target is a list of levelcodes of the next arm and shock is a list of average number of shocks per time step. Instead of roughly 10^4 time steps as in the raw data tracks[end], the DynamicCompressEncoder compressed the subsequent time steps where the fly was in the same abstract state (e.g. in the shock arm) into one step, such that the input, target and shock sequences have now an approximate length of 50.","category":"page"},{"location":"abstract_model/#Fit-a-reinforcement-learning-agent","page":"Abstract Model","title":"Fit a reinforcement learning agent","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Next we define a simple policy gradient agent to fit the data and compute the log-probability of the data given the model and some default parameters that include the discount factor, the learning rate and the initial transition probabilities between abstract states.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Model, PolicyGradientAgent, params, logprob\n\nmodel = Model(PolicyGradientAgent(Din = length(input[1]),\n                                  Dout = length(FlyRL.levels(preprocessor.target.encoder)[1])),\n                                  preprocessor);\nθ = params(model) # some default parameters\nlogprob(model, tracks[end], θ)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us now find the parameters that optimize the log-probability.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: train\nresult = train(model, tracks[end], θ, maxtime = 20, print_interval = 3)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"The log-probability with the fitted parameters is much higher than the value we obtained above.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"logprob(model, tracks[end], result.params)","category":"page"},{"location":"abstract_model/#Generate-simulated-data","page":"Abstract Model","title":"Generate simulated data","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"We can now use the fitted model to obtain simulated tracks.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: Environment, in_shock_arm, simulate\n\nenv = Environment(; preprocessor, shock = in_shock_arm);\nx, s, a, logp = simulate(model.agent, env, result.params, 50)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"We can look at the simulation result by decoding the states x","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: decode\n\ndecode(preprocessor.input, x) |> DataFrame","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us compare the simulated data to the recorded data","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"import FlyRL: plot_compare_probs\n\nplot_compare_probs(decode(preprocessor.input, input).shock_arm,\n                   decode(preprocessor.input, x).shock_arm)","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"(Image: )","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"The top row shows the visitation counts of the different arms in the recorded data and the bottom row shows them for one simulated trial. The first column shows the visitation counts over the whole trajectory (from relative time 0 to relative time 1). The middle row shows the visitation count for the first half of the trial and the last column shows the visitations counts for the second half. We see that the visitation count of the shock arm went down from the first to the second half, both in the recording (top) and the simulation (bottom). Because the simulations are stochastic, each simulated trial will look different, but on average a reduction of the visits to the shock arm is visible.","category":"page"},{"location":"abstract_model/#Model-fitting-for-data-analysis","page":"Abstract Model","title":"Model-fitting for data analysis","text":"","category":"section"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"Let us fit a few recorded tracks and look at the learning rates and discount factors.","category":"page"},{"location":"abstract_model/","page":"Abstract Model","title":"Abstract Model","text":"function fit_lr_and_gamma(model, tracks)\n    η = Float64[]\n    γ = Float64[]\n    for track2fit in tracks\n        θ = params(model)\n        res = train(model, track2fit, θ, maxtime = 20, print_interval = 10)\n        push!(η, res.params.η)\n        push!(γ, FlyRL.sigmoid(res.params.logitγ))\n    end\n    (; η, γ)\nend\nresult = fit_lr_and_gamma(model, tracks)","category":"page"},{"location":"io/","page":"Loading Files","title":"Loading Files","text":"Utility functions for loading raw data.","category":"page"},{"location":"io/","page":"Loading Files","title":"Loading Files","text":"Modules = [FlyRL]\nPages = [\"io.jl\"]","category":"page"}]
}
